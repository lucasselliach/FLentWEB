{"remainingRequest":"D:\\Dev\\SgwProjectxs\\SGWProjectxHotelFrontx\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\Dev\\SgwProjectxs\\SGWProjectxHotelFrontx\\node_modules\\ngx-chips\\esm5\\ngx-chips.js","dependencies":[{"path":"D:\\Dev\\SgwProjectxs\\SGWProjectxHotelFrontx\\node_modules\\ngx-chips\\esm5\\ngx-chips.js","mtime":499162500000},{"path":"D:\\Dev\\SgwProjectxs\\SGWProjectxHotelFrontx\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\Dev\\SgwProjectxs\\SGWProjectxHotelFrontx\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["import { __awaiter, __generator, __extends, __spread } from 'tslib';\nimport { Pipe, Injectable, Input, Component, EventEmitter, Output, ViewChild, ContentChildren, forwardRef, HostListener, Injector, TemplateRef, ElementRef, HostBinding, ChangeDetectorRef, Renderer2, ViewChildren, ContentChild, NgModule } from '@angular/core';\nimport { FormControl, FormGroup, NG_VALUE_ACCESSOR, ReactiveFormsModule, FormsModule, COMPOSITION_BUFFER_MODE } from '@angular/forms';\nimport { filter, first, debounceTime, map } from 'rxjs/operators';\nimport { Ng2Dropdown, Ng2DropdownModule } from 'ng2-material-dropdown';\nimport { animate, trigger, style, transition, keyframes, state } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\nvar escape = function (s) { return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'); };\nvar HighlightPipe = /*@__PURE__*/ (function () {\n    function HighlightPipe() {\n    }\n    HighlightPipe.prototype.transform = function (value, arg) {\n        if (!arg.trim()) {\n            return value;\n        }\n        try {\n            var regex = new RegExp(\"(\" + escape(arg) + \")\", 'i');\n            return value.replace(regex, '<b>$1</b>');\n        }\n        catch (e) {\n            return value;\n        }\n    };\n    return HighlightPipe;\n}());\nvar PLACEHOLDER = '+ Tag';\nvar SECONDARY_PLACEHOLDER = 'Enter a new tag';\nvar KEYDOWN = 'keydown';\nvar KEYUP = 'keyup';\nvar MAX_ITEMS_WARNING = 'The number of items specified was greater than the property max-items.';\nvar ACTIONS_KEYS = {\n    DELETE: 'DELETE',\n    SWITCH_PREV: 'SWITCH_PREV',\n    SWITCH_NEXT: 'SWITCH_NEXT',\n    TAB: 'TAB'\n};\nvar KEY_PRESS_ACTIONS = {\n    8: ACTIONS_KEYS.DELETE,\n    37: ACTIONS_KEYS.SWITCH_PREV,\n    39: ACTIONS_KEYS.SWITCH_NEXT,\n    9: ACTIONS_KEYS.TAB\n};\nvar DRAG_AND_DROP_KEY = 'Text';\nvar NEXT = 'NEXT';\nvar PREV = 'PREV';\nvar DragProvider = /*@__PURE__*/ (function () {\n    function DragProvider() {\n        this.state = {\n            dragging: false,\n            dropping: false,\n            index: undefined\n        };\n    }\n    DragProvider.prototype.setDraggedItem = function (event, tag) {\n        event.dataTransfer.setData(DRAG_AND_DROP_KEY, JSON.stringify(tag));\n    };\n    DragProvider.prototype.getDraggedItem = function (event) {\n        var data = event.dataTransfer.getData(DRAG_AND_DROP_KEY);\n        try {\n            return (JSON.parse(data));\n        }\n        catch (_a) {\n            return;\n        }\n    };\n    DragProvider.prototype.setSender = function (sender) {\n        this.sender = sender;\n    };\n    DragProvider.prototype.setReceiver = function (receiver) {\n        this.receiver = receiver;\n    };\n    DragProvider.prototype.onTagDropped = function (tag, indexDragged, indexDropped) {\n        this.onDragEnd();\n        this.sender.onRemoveRequested(tag, indexDragged);\n        this.receiver.onAddingRequested(false, tag, indexDropped);\n    };\n    DragProvider.prototype.setState = function (state$$1) {\n        this.state = Object.assign({}, this.state, state$$1);\n    };\n    DragProvider.prototype.getState = function (key) {\n        return key ? this.state[key] : this.state;\n    };\n    DragProvider.prototype.onDragEnd = function () {\n        this.setState({\n            dragging: false,\n            dropping: false,\n            index: undefined\n        });\n    };\n    return DragProvider;\n}());\nvar defaults = {\n    tagInput: ({\n        separatorKeys: [],\n        separatorKeyCodes: [],\n        maxItems: Infinity,\n        placeholder: PLACEHOLDER,\n        secondaryPlaceholder: SECONDARY_PLACEHOLDER,\n        validators: [],\n        asyncValidators: [],\n        onlyFromAutocomplete: false,\n        errorMessages: {},\n        theme: '',\n        onTextChangeDebounce: 250,\n        inputId: null,\n        inputClass: '',\n        clearOnBlur: false,\n        hideForm: false,\n        addOnBlur: false,\n        addOnPaste: false,\n        pasteSplitPattern: ',',\n        blinkIfDupe: true,\n        removable: true,\n        editable: false,\n        allowDupes: false,\n        modelAsStrings: false,\n        trimTags: true,\n        ripple: true,\n        tabIndex: '',\n        disable: false,\n        dragZone: '',\n        onRemoving: undefined,\n        onAdding: undefined,\n        displayBy: 'display',\n        identifyBy: 'value',\n        animationDuration: {\n            enter: '250ms',\n            leave: '150ms'\n        }\n    }),\n    dropdown: ({\n        displayBy: 'display',\n        identifyBy: 'value',\n        appendToBody: true,\n        offset: '50 0',\n        focusFirstElement: false,\n        showDropdownIfEmpty: false,\n        minimumTextLength: 1,\n        limitItemsTo: Infinity,\n        keepOpen: true,\n        dynamicUpdate: true,\n        zIndex: 1000,\n        matchingFn: matchingFn\n    })\n};\nfunction matchingFn(value, target) {\n    var targetValue = target[this.displayBy].toString();\n    return targetValue && targetValue\n        .toLowerCase()\n        .indexOf(value.toLowerCase()) >= 0;\n}\nvar OptionsProvider = /*@__PURE__*/ (function () {\n    function OptionsProvider() {\n    }\n    OptionsProvider.prototype.setOptions = function (options) {\n        OptionsProvider.defaults.tagInput = Object.assign({}, defaults.tagInput, options.tagInput);\n        OptionsProvider.defaults.dropdown = Object.assign({}, defaults.dropdown, options.dropdown);\n    };\n    OptionsProvider.defaults = defaults;\n    return OptionsProvider;\n}());\nfunction isObject(obj) {\n    return obj === Object(obj);\n}\nvar TagInputAccessor = /*@__PURE__*/ (function () {\n    function TagInputAccessor() {\n        this._items = [];\n        this.displayBy = OptionsProvider.defaults.tagInput.displayBy;\n        this.identifyBy = OptionsProvider.defaults.tagInput.identifyBy;\n    }\n    Object.defineProperty(TagInputAccessor.prototype, \"items\", {\n        get: function () {\n            return this._items;\n        },\n        set: function (items) {\n            this._items = items;\n            this._onChangeCallback(this._items);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputAccessor.prototype.onTouched = function () {\n        this._onTouchedCallback();\n    };\n    TagInputAccessor.prototype.writeValue = function (items) {\n        this._items = items || [];\n    };\n    TagInputAccessor.prototype.registerOnChange = function (fn) {\n        this._onChangeCallback = fn;\n    };\n    TagInputAccessor.prototype.registerOnTouched = function (fn) {\n        this._onTouchedCallback = fn;\n    };\n    TagInputAccessor.prototype.getItemValue = function (item, fromDropdown) {\n        if (fromDropdown === void 0) {\n            fromDropdown = false;\n        }\n        var property = fromDropdown && this.dropdown ? this.dropdown.identifyBy : this.identifyBy;\n        return isObject(item) ? item[property] : item;\n    };\n    TagInputAccessor.prototype.getItemDisplay = function (item, fromDropdown) {\n        if (fromDropdown === void 0) {\n            fromDropdown = false;\n        }\n        var property = fromDropdown && this.dropdown ? this.dropdown.displayBy : this.displayBy;\n        return isObject(item) ? item[property] : item;\n    };\n    TagInputAccessor.prototype.getItemsWithout = function (index) {\n        return this.items.filter(function (item, position) { return position !== index; });\n    };\n    return TagInputAccessor;\n}());\nfunction listen(listenerType, action, condition) {\n    if (condition === void 0) {\n        condition = true;\n    }\n    if (!this.listeners.hasOwnProperty(listenerType)) {\n        throw new Error('The event entered may be wrong');\n    }\n    if (!condition) {\n        return;\n    }\n    this.listeners[listenerType].push(action);\n}\nvar TagInputForm = /*@__PURE__*/ (function () {\n    function TagInputForm() {\n        this.onSubmit = new EventEmitter();\n        this.onBlur = new EventEmitter();\n        this.onFocus = new EventEmitter();\n        this.onKeyup = new EventEmitter();\n        this.onKeydown = new EventEmitter();\n        this.inputTextChange = new EventEmitter();\n        this.validators = [];\n        this.asyncValidators = [];\n        this.tabindex = '';\n        this.disabled = false;\n        this.item = new FormControl({ value: '', disabled: this.disabled });\n    }\n    Object.defineProperty(TagInputForm.prototype, \"inputText\", {\n        get: function () {\n            return this.item.value;\n        },\n        set: function (text) {\n            this.item.setValue(text);\n            this.inputTextChange.emit(text);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputForm.prototype.ngOnInit = function () {\n        this.item.setValidators(this.validators);\n        this.item.setAsyncValidators(this.asyncValidators);\n        this.form = new FormGroup({\n            item: this.item\n        });\n    };\n    TagInputForm.prototype.ngOnChanges = function (changes) {\n        if (changes[\"disabled\"] && !changes[\"disabled\"].firstChange) {\n            if (changes[\"disabled\"].currentValue) {\n                this.form.controls['item'].disable();\n            }\n            else {\n                this.form.controls['item'].enable();\n            }\n        }\n    };\n    Object.defineProperty(TagInputForm.prototype, \"value\", {\n        get: function () {\n            return (this.form.get('item'));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputForm.prototype.isInputFocused = function () {\n        var doc = typeof document !== 'undefined' ? document : undefined;\n        return doc ? doc.activeElement === this.input.nativeElement : false;\n    };\n    TagInputForm.prototype.getErrorMessages = function (messages) {\n        var _this = this;\n        return Object.keys(messages)\n            .filter(function (err) { return _this.value.hasError(err); })\n            .map(function (err) { return messages[err]; });\n    };\n    TagInputForm.prototype.hasErrors = function () {\n        var _b = this.form, dirty = _b.dirty, value = _b.value, valid = _b.valid;\n        return dirty && value.item && !valid;\n    };\n    TagInputForm.prototype.focus = function () {\n        this.input.nativeElement.focus();\n    };\n    TagInputForm.prototype.blur = function () {\n        this.input.nativeElement.blur();\n    };\n    TagInputForm.prototype.getElementPosition = function () {\n        return this.input.nativeElement.getBoundingClientRect();\n    };\n    TagInputForm.prototype.destroy = function () {\n        var input = this.input.nativeElement;\n        input.parentElement.removeChild(input);\n    };\n    TagInputForm.prototype.onKeyDown = function ($event) {\n        this.inputText = this.value.value;\n        if ($event.key === 'Enter') {\n            this.submit($event);\n            this.inputText = '';\n        }\n        return this.onKeydown.emit($event);\n    };\n    TagInputForm.prototype.onKeyUp = function ($event) {\n        this.inputText = this.value.value;\n        return this.onKeyup.emit($event);\n    };\n    TagInputForm.prototype.submit = function ($event) {\n        $event.preventDefault();\n        if (this.form.valid) {\n            this.onSubmit.emit($event);\n        }\n    };\n    return TagInputForm;\n}());\nvar defaults$1 = forwardRef(function () { return OptionsProvider.defaults.dropdown; });\nvar TagInputDropdown = /*@__PURE__*/ (function () {\n    function TagInputDropdown(injector) {\n        var _this = this;\n        this.injector = injector;\n        this.offset = new defaults$1().offset;\n        this.focusFirstElement = new defaults$1().focusFirstElement;\n        this.showDropdownIfEmpty = new defaults$1().showDropdownIfEmpty;\n        this.minimumTextLength = new defaults$1().minimumTextLength;\n        this.limitItemsTo = new defaults$1().limitItemsTo;\n        this.displayBy = new defaults$1().displayBy;\n        this.identifyBy = new defaults$1().identifyBy;\n        this.matchingFn = new defaults$1().matchingFn;\n        this.appendToBody = new defaults$1().appendToBody;\n        this.keepOpen = new defaults$1().keepOpen;\n        this.dynamicUpdate = new defaults$1().dynamicUpdate;\n        this.zIndex = new defaults$1().zIndex;\n        this.items = [];\n        this.tagInput = this.injector.get(TagInputComponent);\n        this._autocompleteItems = [];\n        this.show = function () {\n            var maxItemsReached = _this.tagInput.items.length === _this.tagInput.maxItems;\n            var value = _this.getFormValue();\n            var hasMinimumText = value.trim().length >= _this.minimumTextLength;\n            var position = _this.calculatePosition();\n            var items = _this.getMatchingItems(value);\n            var hasItems = items.length > 0;\n            var isHidden = _this.isVisible === false;\n            var showDropdownIfEmpty = _this.showDropdownIfEmpty && hasItems && !value;\n            var isDisabled = _this.tagInput.disable;\n            var shouldShow = isHidden && ((hasItems && hasMinimumText) || showDropdownIfEmpty);\n            var shouldHide = _this.isVisible && !hasItems;\n            if (_this.autocompleteObservable && hasMinimumText) {\n                return _this.getItemsFromObservable(value);\n            }\n            if ((!_this.showDropdownIfEmpty && !value) || maxItemsReached || isDisabled) {\n                return _this.dropdown.hide();\n            }\n            _this.setItems(items);\n            if (shouldShow) {\n                _this.dropdown.show(position);\n            }\n            else if (shouldHide) {\n                _this.hide();\n            }\n        };\n        this.requestAdding = function (item) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var tag;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            tag = this.createTagModel(item);\n                            return [4 /*yield*/, this.tagInput.onAddingRequested(true, tag).catch(function () { })];\n                        case 1:\n                            _b.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        this.resetItems = function () {\n            _this.items = [];\n        };\n        this.getItemsFromObservable = function (text) {\n            _this.setLoadingState(true);\n            var subscribeFn = function (data) {\n                _this.setLoadingState(false)\n                    .populateItems(data);\n                _this.setItems(_this.getMatchingItems(text));\n                if (_this.items.length) {\n                    _this.dropdown.show(_this.calculatePosition());\n                }\n                else {\n                    _this.dropdown.hide();\n                }\n            };\n            _this.autocompleteObservable(text)\n                .pipe(first())\n                .subscribe(subscribeFn, function () { return _this.setLoadingState(false); });\n        };\n    }\n    Object.defineProperty(TagInputDropdown.prototype, \"autocompleteItems\", {\n        get: function () {\n            var _this = this;\n            var items = this._autocompleteItems;\n            if (!items) {\n                return [];\n            }\n            return items.map(function (item) {\n                return typeof item === 'string' ? (_b = {}, _b[_this.displayBy] = item, _b[_this.identifyBy] = item, _b) : item;\n                var _b;\n            });\n        },\n        set: function (items) {\n            this._autocompleteItems = items;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputDropdown.prototype.ngOnInit = function () {\n        var _this = this;\n        this.onItemClicked().subscribe(function (item) {\n            _this.requestAdding(item);\n        });\n        this.onHide().subscribe(this.resetItems);\n        var DEBOUNCE_TIME = 200;\n        var KEEP_OPEN = this.keepOpen;\n        this.tagInput\n            .onTextChange\n            .asObservable()\n            .pipe(debounceTime(DEBOUNCE_TIME), filter(function (value) {\n            if (KEEP_OPEN === false) {\n                return value.length > 0;\n            }\n            return true;\n        }))\n            .subscribe(this.show);\n    };\n    TagInputDropdown.prototype.updatePosition = function () {\n        var position = this.tagInput.inputForm.getElementPosition();\n        this.dropdown.menu.updatePosition(position, this.dynamicUpdate);\n    };\n    Object.defineProperty(TagInputDropdown.prototype, \"isVisible\", {\n        get: function () {\n            return this.dropdown.menu.state.menuState.isVisible;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputDropdown.prototype.onHide = function () {\n        return this.dropdown.onHide;\n    };\n    TagInputDropdown.prototype.onItemClicked = function () {\n        return this.dropdown.onItemClicked;\n    };\n    Object.defineProperty(TagInputDropdown.prototype, \"selectedItem\", {\n        get: function () {\n            return this.dropdown.menu.state.dropdownState.selectedItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TagInputDropdown.prototype, \"state\", {\n        get: function () {\n            return this.dropdown.menu.state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputDropdown.prototype.hide = function () {\n        this.resetItems();\n        this.dropdown.hide();\n    };\n    TagInputDropdown.prototype.scrollListener = function () {\n        if (!this.isVisible || !this.dynamicUpdate) {\n            return;\n        }\n        this.updatePosition();\n    };\n    TagInputDropdown.prototype.onWindowBlur = function () {\n        this.dropdown.hide();\n    };\n    TagInputDropdown.prototype.getFormValue = function () {\n        var formValue = this.tagInput.formValue;\n        return formValue ? formValue.toString().trim() : '';\n    };\n    TagInputDropdown.prototype.calculatePosition = function () {\n        return this.tagInput.inputForm.getElementPosition();\n    };\n    TagInputDropdown.prototype.createTagModel = function (item) {\n        var display = typeof item.value === 'string' ? item.value : item.value[this.displayBy];\n        var value = typeof item.value === 'string' ? item.value : item.value[this.identifyBy];\n        return Object.assign({}, item.value, (_b = {}, _b[this.tagInput.displayBy] = display, _b[this.tagInput.identifyBy] = value, _b));\n        var _b;\n    };\n    TagInputDropdown.prototype.getMatchingItems = function (value) {\n        var _this = this;\n        if (!value && !this.showDropdownIfEmpty) {\n            return [];\n        }\n        var dupesAllowed = this.tagInput.allowDupes;\n        return this.autocompleteItems.filter(function (item) {\n            var hasValue = dupesAllowed ? false : _this.tagInput.tags.some(function (tag) {\n                var identifyBy = _this.tagInput.identifyBy;\n                var model = typeof tag.model === 'string' ? tag.model : tag.model[identifyBy];\n                return model === item[_this.identifyBy];\n            });\n            return _this.matchingFn(value, item) && (hasValue === false);\n        });\n    };\n    TagInputDropdown.prototype.setItems = function (items) {\n        this.items = items.slice(0, this.limitItemsTo || items.length);\n    };\n    TagInputDropdown.prototype.populateItems = function (data) {\n        var _this = this;\n        this.autocompleteItems = data.map(function (item) {\n            return typeof item === 'string' ? (_b = {}, _b[_this.displayBy] = item, _b[_this.identifyBy] = item, _b) : item;\n            var _b;\n        });\n        return this;\n    };\n    TagInputDropdown.prototype.setLoadingState = function (state$$1) {\n        this.tagInput.isLoading = state$$1;\n        return this;\n    };\n    return TagInputDropdown;\n}());\nvar TagRipple = /*@__PURE__*/ (function () {\n    function TagRipple() {\n        this.state = 'none';\n    }\n    return TagRipple;\n}());\nvar navigator = typeof window !== 'undefined' ? window.navigator : {\n    userAgent: 'Chrome',\n    vendor: 'Google Inc'\n};\nvar isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\nvar TagComponent = /*@__PURE__*/ (function () {\n    function TagComponent(element, renderer, cdRef) {\n        this.element = element;\n        this.renderer = renderer;\n        this.cdRef = cdRef;\n        this.disabled = false;\n        this.onSelect = new EventEmitter();\n        this.onRemove = new EventEmitter();\n        this.onBlur = new EventEmitter();\n        this.onKeyDown = new EventEmitter();\n        this.onTagEdited = new EventEmitter();\n        this.editing = false;\n        this.rippleState = \"none\";\n    }\n    Object.defineProperty(TagComponent.prototype, \"readonly\", {\n        get: function () {\n            return typeof this.model !== \"string\" && this.model[\"readonly\"] === true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagComponent.prototype.select = function ($event) {\n        if (this.readonly || this.disabled) {\n            return;\n        }\n        if ($event) {\n            $event.stopPropagation();\n        }\n        this.focus();\n        this.onSelect.emit(this.model);\n    };\n    TagComponent.prototype.remove = function ($event) {\n        $event.stopPropagation();\n        this.onRemove.emit(this);\n    };\n    TagComponent.prototype.focus = function () {\n        this.element.nativeElement.focus();\n    };\n    TagComponent.prototype.move = function () {\n        this.moving = true;\n    };\n    TagComponent.prototype.keydown = function (event) {\n        if (this.editing) {\n            if (event.keyCode === 13) {\n                return this.disableEditMode(event);\n            }\n        }\n        this.onKeyDown.emit({ event: event, model: this.model });\n    };\n    TagComponent.prototype.blink = function () {\n        var classList = this.element.nativeElement.classList;\n        classList.add(\"blink\");\n        setTimeout(function () { return classList.remove(\"blink\"); }, 50);\n    };\n    TagComponent.prototype.toggleEditMode = function () {\n        if (this.editable) {\n            return this.editing ? undefined : this.activateEditMode();\n        }\n    };\n    TagComponent.prototype.onBlurred = function (event) {\n        if (!this.editable) {\n            return;\n        }\n        this.disableEditMode();\n        var value = event.target.innerText;\n        var result = typeof this.model === \"string\"\n            ? value\n            : Object.assign({}, this.model, (_b = {}, _b[this.displayBy] = value, _b));\n        this.onBlur.emit(result);\n        var _b;\n    };\n    TagComponent.prototype.getDisplayValue = function (item) {\n        return typeof item === \"string\" ? item : item[this.displayBy];\n    };\n    Object.defineProperty(TagComponent.prototype, \"isRippleVisible\", {\n        get: function () {\n            return !this.readonly && !this.editing && isChrome && this.hasRipple;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagComponent.prototype.disableEditMode = function ($event) {\n        var classList = this.element.nativeElement.classList;\n        var input = this.getContentEditableText();\n        this.editing = false;\n        classList.remove(\"tag--editing\");\n        if (!input) {\n            this.setContentEditableText(this.model);\n            return;\n        }\n        this.storeNewValue(input);\n        this.cdRef.detectChanges();\n        if ($event) {\n            $event.preventDefault();\n        }\n    };\n    TagComponent.prototype.isDeleteIconVisible = function () {\n        return (!this.readonly && !this.disabled && this.removable && !this.editing);\n    };\n    TagComponent.prototype.getContentEditableText = function () {\n        var input = this.getContentEditable();\n        return input ? input.innerText.trim() : \"\";\n    };\n    TagComponent.prototype.setContentEditableText = function (model) {\n        var input = this.getContentEditable();\n        var value = this.getDisplayValue(model);\n        input.innerText = value;\n    };\n    TagComponent.prototype.activateEditMode = function () {\n        var classList = this.element.nativeElement.classList;\n        classList.add('tag--editing');\n        this.editing = true;\n    };\n    TagComponent.prototype.storeNewValue = function (input) {\n        var _this = this;\n        var exists = function (tag) {\n            return typeof tag === 'string'\n                ? tag === input\n                : tag[_this.displayBy] === input;\n        };\n        var hasId = function () {\n            return _this.model[_this.identifyBy] !== _this.model[_this.displayBy];\n        };\n        if (exists(this.model)) {\n            return;\n        }\n        var model = typeof this.model === 'string'\n            ? input\n            : (_b = {\n                index: this.index\n            }, _b[this.identifyBy] = hasId()\n                ? this.model[this.identifyBy]\n                : input, _b[this.displayBy] = input, _b);\n        if (this.canAddTag(model)) {\n            this.onTagEdited.emit({ tag: model, index: this.index });\n        }\n        else {\n            this.setContentEditableText(this.model);\n        }\n        var _b;\n    };\n    TagComponent.prototype.getContentEditable = function () {\n        return this.element.nativeElement.querySelector('[contenteditable]');\n    };\n    return TagComponent;\n}());\nvar animations = [\n    trigger('animation', [\n        state('in', style({\n            opacity: 1\n        })),\n        state('out', style({\n            opacity: 0\n        })),\n        transition(':enter', [\n            animate(\"{{ enter }}\", keyframes([\n                style({ opacity: 0, offset: 0, transform: 'translate(0px, 20px)' }),\n                style({ opacity: 0.3, offset: 0.3, transform: 'translate(0px, -10px)' }),\n                style({ opacity: 0.5, offset: 0.5, transform: 'translate(0px, 0px)' }),\n                style({ opacity: 0.75, offset: 0.75, transform: 'translate(0px, 5px)' }),\n                style({ opacity: 1, offset: 1, transform: 'translate(0px, 0px)' })\n            ]))\n        ]),\n        transition(':leave', [\n            animate(\"{{ leave }}\", keyframes([\n                style({ opacity: 1, transform: 'translateX(0)', offset: 0 }),\n                style({ opacity: 1, transform: 'translateX(-15px)', offset: 0.7 }),\n                style({ opacity: 0, transform: 'translateX(100%)', offset: 1.0 })\n            ]))\n        ])\n    ])\n];\nvar DragEvent = ((window)).DragEvent;\nvar CUSTOM_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return TagInputComponent; }),\n    multi: true\n};\nvar defaults$2 = forwardRef(function () { return OptionsProvider.defaults.tagInput; });\nvar TagInputComponent = /*@__PURE__*/ (function (_super) {\n    __extends(TagInputComponent, _super);\n    function TagInputComponent(renderer, dragProvider) {\n        var _this = _super.call(this) || this;\n        _this.renderer = renderer;\n        _this.dragProvider = dragProvider;\n        _this.separatorKeys = new defaults$2().separatorKeys;\n        _this.separatorKeyCodes = new defaults$2().separatorKeyCodes;\n        _this.placeholder = new defaults$2().placeholder;\n        _this.secondaryPlaceholder = new defaults$2().secondaryPlaceholder;\n        _this.maxItems = new defaults$2().maxItems;\n        _this.validators = new defaults$2().validators;\n        _this.asyncValidators = new defaults$2().asyncValidators;\n        _this.onlyFromAutocomplete = new defaults$2().onlyFromAutocomplete;\n        _this.errorMessages = new defaults$2().errorMessages;\n        _this.theme = new defaults$2().theme;\n        _this.onTextChangeDebounce = new defaults$2().onTextChangeDebounce;\n        _this.inputId = new defaults$2().inputId;\n        _this.inputClass = new defaults$2().inputClass;\n        _this.clearOnBlur = new defaults$2().clearOnBlur;\n        _this.hideForm = new defaults$2().hideForm;\n        _this.addOnBlur = new defaults$2().addOnBlur;\n        _this.addOnPaste = new defaults$2().addOnPaste;\n        _this.pasteSplitPattern = new defaults$2().pasteSplitPattern;\n        _this.blinkIfDupe = new defaults$2().blinkIfDupe;\n        _this.removable = new defaults$2().removable;\n        _this.editable = new defaults$2().editable;\n        _this.allowDupes = new defaults$2().allowDupes;\n        _this.modelAsStrings = new defaults$2().modelAsStrings;\n        _this.trimTags = new defaults$2().trimTags;\n        _this.ripple = new defaults$2().ripple;\n        _this.tabindex = new defaults$2().tabIndex;\n        _this.disable = new defaults$2().disable;\n        _this.dragZone = new defaults$2().dragZone;\n        _this.onRemoving = new defaults$2().onRemoving;\n        _this.onAdding = new defaults$2().onAdding;\n        _this.animationDuration = new defaults$2().animationDuration;\n        _this.onAdd = new EventEmitter();\n        _this.onRemove = new EventEmitter();\n        _this.onSelect = new EventEmitter();\n        _this.onFocus = new EventEmitter();\n        _this.onBlur = new EventEmitter();\n        _this.onTextChange = new EventEmitter();\n        _this.onPaste = new EventEmitter();\n        _this.onValidationError = new EventEmitter();\n        _this.onTagEdited = new EventEmitter();\n        _this.isLoading = false;\n        _this.listeners = (_b = {}, _b[KEYDOWN] = ([]), _b[KEYUP] = ([]), _b);\n        _this.inputTextChange = new EventEmitter();\n        _this.inputTextValue = '';\n        _this.errors = [];\n        _this.appendTag = function (tag, index) {\n            if (index === void 0) {\n                index = _this.items.length;\n            }\n            var items = _this.items;\n            var model = _this.modelAsStrings ? tag[_this.identifyBy] : tag;\n            _this.items = __spread(items.slice(0, index), [\n                model\n            ], items.slice(index, items.length));\n        };\n        _this.createTag = function (model) {\n            var trim = function (val, key) {\n                return typeof val === 'string' ? val.trim() : val[key];\n            };\n            return Object.assign({}, typeof model !== 'string' ? model : {}, (_b = {}, _b[_this.displayBy] = _this.trimTags ? trim(model, _this.displayBy) : model, _b[_this.identifyBy] = _this.trimTags ? trim(model, _this.identifyBy) : model, _b));\n            var _b;\n        };\n        _this.isTagValid = function (tag, fromAutocomplete) {\n            if (fromAutocomplete === void 0) {\n                fromAutocomplete = false;\n            }\n            var selectedItem = _this.dropdown ? _this.dropdown.selectedItem : undefined;\n            var value = _this.getItemDisplay(tag).trim();\n            if (selectedItem && !fromAutocomplete || !value) {\n                return false;\n            }\n            var dupe = _this.findDupe(tag, fromAutocomplete);\n            if (!_this.allowDupes && dupe && _this.blinkIfDupe) {\n                var model = _this.tags.find(function (item) {\n                    return _this.getItemValue(item.model) === _this.getItemValue(dupe);\n                });\n                if (model) {\n                    model.blink();\n                }\n            }\n            var isFromAutocomplete = fromAutocomplete && _this.onlyFromAutocomplete;\n            var assertions = [\n                !dupe || _this.allowDupes,\n                !_this.maxItemsReached,\n                ((isFromAutocomplete) || !_this.onlyFromAutocomplete)\n            ];\n            return assertions.filter(Boolean).length === assertions.length;\n        };\n        _this.onPasteCallback = function (data) {\n            return __awaiter(_this, void 0, void 0, function () {\n                var _this = this;\n                var getText, text, requests, resetInput;\n                return __generator(this, function (_b) {\n                    getText = function () {\n                        var isIE = Boolean(((window)).clipboardData);\n                        var clipboardData = isIE ? (((window)).clipboardData) : data.clipboardData;\n                        var type = isIE ? 'Text' : 'text/plain';\n                        return clipboardData.getData(type) || '';\n                    };\n                    text = getText();\n                    requests = text\n                        .split(this.pasteSplitPattern)\n                        .map(function (item) {\n                        var tag = _this.createTag(item);\n                        _this.setInputValue(tag[_this.displayBy]);\n                        return _this.onAddingRequested(false, tag);\n                    });\n                    resetInput = function () { return setTimeout(function () { return _this.setInputValue(''); }, 50); };\n                    Promise.all(requests).then(function () {\n                        _this.onPaste.emit(text);\n                        resetInput();\n                    })\n                        .catch(resetInput);\n                    return [2 /*return*/];\n                });\n            });\n        };\n        return _this;\n        var _b;\n    }\n    Object.defineProperty(TagInputComponent.prototype, \"inputText\", {\n        get: function () {\n            return this.inputTextValue;\n        },\n        set: function (text) {\n            this.inputTextValue = text;\n            this.inputTextChange.emit(text);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TagInputComponent.prototype, \"tabindexAttr\", {\n        get: function () {\n            return this.tabindex !== '' ? '-1' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.setUpKeypressListeners();\n        this.setupSeparatorKeysListener();\n        this.setUpInputKeydownListeners();\n        if (this.onTextChange.observers.length) {\n            this.setUpTextChangeSubscriber();\n        }\n        if (this.clearOnBlur || this.addOnBlur) {\n            this.setUpOnBlurSubscriber();\n        }\n        if (this.addOnPaste) {\n            this.setUpOnPasteListener();\n        }\n        var statusChanges$ = this.inputForm.form.statusChanges;\n        statusChanges$.pipe(filter(function (status) { return status !== 'PENDING'; })).subscribe(function () {\n            _this.errors = _this.inputForm.getErrorMessages(_this.errorMessages);\n        });\n        this.isProgressBarVisible$ = statusChanges$.pipe(map(function (status) {\n            return status === 'PENDING' || _this.isLoading;\n        }));\n        if (this.hideForm) {\n            this.inputForm.destroy();\n        }\n    };\n    TagInputComponent.prototype.ngOnInit = function () {\n        var hasReachedMaxItems = this.maxItems !== undefined &&\n            this.items &&\n            this.items.length > this.maxItems;\n        if (hasReachedMaxItems) {\n            this.maxItems = this.items.length;\n            console.warn(MAX_ITEMS_WARNING);\n        }\n        this.editable = this.onlyFromAutocomplete ? false : this.editable;\n        this.setAnimationMetadata();\n    };\n    TagInputComponent.prototype.onRemoveRequested = function (tag, index) {\n        var _this = this;\n        return new Promise(function (resolve) {\n            var subscribeFn = function (model) {\n                _this.removeItem(model, index);\n                resolve(tag);\n            };\n            _this.onRemoving ?\n                _this.onRemoving(tag)\n                    .pipe(first())\n                    .subscribe(subscribeFn) : subscribeFn(tag);\n        });\n    };\n    TagInputComponent.prototype.onAddingRequested = function (fromAutocomplete, tag, index) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var subscribeFn = function (model) {\n                return _this\n                    .addItem(fromAutocomplete, model, index)\n                    .then(resolve)\n                    .catch(reject);\n            };\n            return _this.onAdding ?\n                _this.onAdding(tag)\n                    .pipe(first())\n                    .subscribe(subscribeFn, reject) : subscribeFn(tag);\n        });\n    };\n    TagInputComponent.prototype.selectItem = function (item, emit) {\n        if (emit === void 0) {\n            emit = true;\n        }\n        var isReadonly = item && typeof item !== 'string' && item[\"readonly\"];\n        if (isReadonly || this.selectedTag === item) {\n            return;\n        }\n        this.selectedTag = item;\n        if (emit) {\n            this.onSelect.emit(item);\n        }\n    };\n    TagInputComponent.prototype.fireEvents = function (eventName, $event) {\n        var _this = this;\n        this.listeners[eventName].forEach(function (listener) { return listener.call(_this, $event); });\n    };\n    TagInputComponent.prototype.handleKeydown = function (data) {\n        var event = data.event;\n        var key = event.keyCode || event.which;\n        var shiftKey = event.shiftKey || false;\n        switch (KEY_PRESS_ACTIONS[key]) {\n            case ACTIONS_KEYS.DELETE:\n                if (this.selectedTag && this.removable) {\n                    var index = this.items.indexOf(this.selectedTag);\n                    this.onRemoveRequested(this.selectedTag, index);\n                }\n                break;\n            case ACTIONS_KEYS.SWITCH_PREV:\n                this.moveToTag(data.model, PREV);\n                break;\n            case ACTIONS_KEYS.SWITCH_NEXT:\n                this.moveToTag(data.model, NEXT);\n                break;\n            case ACTIONS_KEYS.TAB:\n                if (shiftKey) {\n                    if (this.isFirstTag(data.model)) {\n                        return;\n                    }\n                    this.moveToTag(data.model, PREV);\n                }\n                else {\n                    if (this.isLastTag(data.model) && (this.disable || this.maxItemsReached)) {\n                        return;\n                    }\n                    this.moveToTag(data.model, NEXT);\n                }\n                break;\n            default:\n                return;\n        }\n        event.preventDefault();\n    };\n    TagInputComponent.prototype.onFormSubmit = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.onAddingRequested(false, this.formValue)];\n                    case 1:\n                        _b.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        _a_1 = _b.sent();\n                        return [2 /*return*/];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    TagInputComponent.prototype.setInputValue = function (value, emitEvent) {\n        if (emitEvent === void 0) {\n            emitEvent = true;\n        }\n        var control = this.getControl();\n        control.setValue(value, { emitEvent: emitEvent });\n    };\n    TagInputComponent.prototype.getControl = function () {\n        return (this.inputForm.value);\n    };\n    TagInputComponent.prototype.focus = function (applyFocus, displayAutocomplete) {\n        if (applyFocus === void 0) {\n            applyFocus = false;\n        }\n        if (displayAutocomplete === void 0) {\n            displayAutocomplete = false;\n        }\n        if (this.dragProvider.getState('dragging')) {\n            return;\n        }\n        this.selectItem(undefined, false);\n        if (applyFocus) {\n            this.inputForm.focus();\n            this.onFocus.emit(this.formValue);\n        }\n    };\n    TagInputComponent.prototype.blur = function () {\n        this.onTouched();\n        this.onBlur.emit(this.formValue);\n    };\n    TagInputComponent.prototype.hasErrors = function () {\n        return this.inputForm && this.inputForm.hasErrors();\n    };\n    TagInputComponent.prototype.isInputFocused = function () {\n        return this.inputForm && this.inputForm.isInputFocused();\n    };\n    TagInputComponent.prototype.hasCustomTemplate = function () {\n        var template = this.templates ? this.templates.first : undefined;\n        var menuTemplate = this.dropdown && this.dropdown.templates ?\n            this.dropdown.templates.first : undefined;\n        return Boolean(template && template !== menuTemplate);\n    };\n    Object.defineProperty(TagInputComponent.prototype, \"maxItemsReached\", {\n        get: function () {\n            return this.maxItems !== undefined &&\n                this.items.length >= this.maxItems;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TagInputComponent.prototype, \"formValue\", {\n        get: function () {\n            var form = this.inputForm.value;\n            return form ? form.value : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TagInputComponent.prototype.onDragStarted = function (event, tag, index) {\n        event.stopPropagation();\n        var item = ({ zone: this.dragZone, tag: tag, index: index });\n        this.dragProvider.setSender(this);\n        this.dragProvider.setDraggedItem(event, item);\n        this.dragProvider.setState({ dragging: true, index: index });\n    };\n    TagInputComponent.prototype.onDragOver = function (event, index) {\n        this.dragProvider.setState({ dropping: true });\n        this.dragProvider.setReceiver(this);\n        event.preventDefault();\n    };\n    TagInputComponent.prototype.onTagDropped = function (event, index) {\n        var item = this.dragProvider.getDraggedItem(event);\n        if (!item || item.zone !== this.dragZone) {\n            return;\n        }\n        this.dragProvider.onTagDropped(item.tag, item.index, index);\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    TagInputComponent.prototype.isDropping = function () {\n        var isReceiver = this.dragProvider.receiver === this;\n        var isDropping = this.dragProvider.getState('dropping');\n        return Boolean(isReceiver && isDropping);\n    };\n    TagInputComponent.prototype.onTagBlurred = function (changedElement, index) {\n        this.items[index] = changedElement;\n        this.blur();\n    };\n    TagInputComponent.prototype.trackBy = function (index, item) {\n        return item[this.identifyBy];\n    };\n    TagInputComponent.prototype.updateEditedTag = function (_b) {\n        var tag = _b.tag, index = _b.index;\n        this.onTagEdited.emit(tag);\n    };\n    TagInputComponent.prototype.moveToTag = function (item, direction) {\n        var isLast = this.isLastTag(item);\n        var isFirst = this.isFirstTag(item);\n        var stopSwitch = (direction === NEXT && isLast) ||\n            (direction === PREV && isFirst);\n        if (stopSwitch) {\n            this.focus(true);\n            return;\n        }\n        var offset = direction === NEXT ? 1 : -1;\n        var index = this.getTagIndex(item) + offset;\n        var tag = this.getTagAtIndex(index);\n        return tag.select.call(tag);\n    };\n    TagInputComponent.prototype.isFirstTag = function (item) {\n        return this.tags.first.model === item;\n    };\n    TagInputComponent.prototype.isLastTag = function (item) {\n        return this.tags.last.model === item;\n    };\n    TagInputComponent.prototype.getTagIndex = function (item) {\n        var tags = this.tags.toArray();\n        return tags.findIndex(function (tag) { return tag.model === item; });\n    };\n    TagInputComponent.prototype.getTagAtIndex = function (index) {\n        var tags = this.tags.toArray();\n        return tags[index];\n    };\n    TagInputComponent.prototype.removeItem = function (tag, index) {\n        this.items = this.getItemsWithout(index);\n        if (this.selectedTag === tag) {\n            this.selectItem(undefined, false);\n        }\n        this.focus(true, false);\n        this.onRemove.emit(tag);\n    };\n    TagInputComponent.prototype.addItem = function (fromAutocomplete, item, index) {\n        var _this = this;\n        if (fromAutocomplete === void 0) {\n            fromAutocomplete = false;\n        }\n        var display = this.getItemDisplay(item);\n        var tag = this.createTag(item);\n        if (fromAutocomplete) {\n            this.setInputValue(this.getItemValue(item, true));\n        }\n        return new Promise(function (resolve, reject) {\n            var reset = function () {\n                _this.setInputValue('');\n                _this.focus(true, false);\n                resolve(display);\n            };\n            var appendItem = function () {\n                _this.appendTag(tag, index);\n                _this.onAdd.emit(tag);\n                if (!_this.dropdown) {\n                    return;\n                }\n                _this.dropdown.hide();\n                if (_this.dropdown.showDropdownIfEmpty) {\n                    _this.dropdown.show();\n                }\n            };\n            var status = _this.inputForm.form.status;\n            var isTagValid = _this.isTagValid(tag, fromAutocomplete);\n            var onValidationError = function () {\n                _this.onValidationError.emit(tag);\n                return reject();\n            };\n            if (status === 'VALID' && isTagValid) {\n                appendItem();\n                return reset();\n            }\n            if (status === 'INVALID' || !isTagValid) {\n                reset();\n                return onValidationError();\n            }\n            if (status === 'PENDING') {\n                var statusUpdate$ = _this.inputForm.form.statusChanges;\n                return statusUpdate$\n                    .pipe(filter(function (statusUpdate) { return statusUpdate !== 'PENDING'; }), first())\n                    .subscribe(function (statusUpdate) {\n                    if (statusUpdate === 'VALID' && isTagValid) {\n                        appendItem();\n                        resolve();\n                    }\n                    else {\n                        onValidationError();\n                    }\n                });\n            }\n        });\n    };\n    TagInputComponent.prototype.setupSeparatorKeysListener = function () {\n        var _this = this;\n        var useSeparatorKeys = this.separatorKeyCodes.length > 0 || this.separatorKeys.length > 0;\n        var listener = function ($event) {\n            var hasKeyCode = _this.separatorKeyCodes.indexOf($event.keyCode) >= 0;\n            var hasKey = _this.separatorKeys.indexOf($event.key) >= 0;\n            var isIMEProcessing = $event.keyCode === 229;\n            if (hasKeyCode || (hasKey && !isIMEProcessing)) {\n                $event.preventDefault();\n                _this.onAddingRequested(false, _this.formValue)\n                    .catch(function () { });\n            }\n        };\n        listen.call(this, KEYDOWN, listener, useSeparatorKeys);\n    };\n    TagInputComponent.prototype.setUpKeypressListeners = function () {\n        var _this = this;\n        var listener = function ($event) {\n            var isCorrectKey = $event.keyCode === 37 || $event.keyCode === 8;\n            if (isCorrectKey &&\n                !_this.formValue &&\n                _this.items.length) {\n                _this.tags.last.select.call(_this.tags.last);\n            }\n        };\n        listen.call(this, KEYDOWN, listener);\n    };\n    TagInputComponent.prototype.setUpInputKeydownListeners = function () {\n        var _this = this;\n        this.inputForm.onKeydown.subscribe(function (event) {\n            _this.fireEvents('keydown', event);\n            if (event.key === 'Backspace' && _this.formValue.trim() === '') {\n                event.preventDefault();\n            }\n        });\n    };\n    TagInputComponent.prototype.setUpOnPasteListener = function () {\n        var _this = this;\n        var input = this.inputForm.input.nativeElement;\n        this.renderer.listen(input, 'paste', function (event) {\n            _this.onPasteCallback(event);\n            event.preventDefault();\n            return true;\n        });\n    };\n    TagInputComponent.prototype.setUpTextChangeSubscriber = function () {\n        var _this = this;\n        this.inputForm.form\n            .valueChanges\n            .pipe(debounceTime(this.onTextChangeDebounce))\n            .subscribe(function (value) {\n            _this.onTextChange.emit(value.item);\n        });\n    };\n    TagInputComponent.prototype.setUpOnBlurSubscriber = function () {\n        var _this = this;\n        var filterFn = function () {\n            var isVisible = _this.dropdown && _this.dropdown.isVisible;\n            return !isVisible && !!_this.formValue;\n        };\n        this.inputForm\n            .onBlur\n            .pipe(debounceTime(100), filter(filterFn))\n            .subscribe(function () {\n            var reset = function () { return _this.setInputValue(''); };\n            if (_this.addOnBlur) {\n                return _this\n                    .onAddingRequested(false, _this.formValue)\n                    .then(reset)\n                    .catch(reset);\n            }\n            reset();\n        });\n    };\n    TagInputComponent.prototype.findDupe = function (tag, isFromAutocomplete) {\n        var _this = this;\n        var identifyBy = isFromAutocomplete ? this.dropdown.identifyBy : this.identifyBy;\n        var id = tag[identifyBy];\n        return this.items.find(function (item) { return _this.getItemValue(item) === id; });\n    };\n    TagInputComponent.prototype.setAnimationMetadata = function () {\n        this.animationMetadata = {\n            value: 'in',\n            params: Object.assign({}, this.animationDuration)\n        };\n    };\n    return TagInputComponent;\n}(TagInputAccessor));\nvar DeleteIconComponent = /*@__PURE__*/ (function () {\n    function DeleteIconComponent() {\n    }\n    return DeleteIconComponent;\n}());\nvar optionsProvider = new OptionsProvider();\nvar TagInputModule = /*@__PURE__*/ (function () {\n    function TagInputModule() {\n    }\n    TagInputModule.withDefaults = function (options) {\n        optionsProvider.setOptions(options);\n    };\n    return TagInputModule;\n}());\nexport { TagInputModule, TagInputDropdown, DeleteIconComponent, TagInputForm, TagRipple, TagComponent, TagInputComponent, animations as b, TagInputAccessor as a, HighlightPipe as d, DragProvider as c };\n//# sourceMappingURL=ngx-chips.js.map\n",null]}