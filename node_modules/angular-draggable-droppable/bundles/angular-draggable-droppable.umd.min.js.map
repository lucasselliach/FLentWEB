{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://angular-draggable-droppable/lib/draggable-helper.provider.ts","ng://angular-draggable-droppable/lib/draggable-scroll-container.directive.ts","ng://angular-draggable-droppable/lib/draggable.directive.ts","ng://angular-draggable-droppable/lib/droppable.directive.ts","ng://angular-draggable-droppable/lib/drag-and-drop.module.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","DraggableHelper","Subject","Injectable","args","providedIn","DraggableScrollContainerDirective","elementRef","Directive","selector","ElementRef","DraggableDirective","element","renderer","draggableHelper","zone","vcr","scrollContainer","document","x","y","EventEmitter","ngOnInit","_this","checkEventListeners","pointerDragged$","pointerDown$","pipe","filter","canDrag","mergeMap","pointerDownEvent","event","stopPropagation","globalDragStyle","createElement","setAttribute","appendChild","createText","head","startScrollPosition","getScrollPosition","scrollContainerScroll$","Observable","observer","nativeElement","listen","startWith","map","currentDrag$","cancelDrag$","ReplaySubject","run","dragPointerDown","dragComplete$","merge","pointerUp$","destroy$","share","pointerMove","combineLatest","pointerMove$","_a","_b","pointerMoveEvent","scroll","transformX","clientX","transformY","clientY","scrollLeft","left","scrollTop","top","moveData","dragSnapGrid","Math","round","dragAxis","scrollX","scrollY","validateDrag","takeUntil","dragStarted$","take","dragEnded$","takeLast","subscribe","dragStart","addClass","dragActiveClass","ghostDragEnabled","rect","getBoundingClientRect","clone_1","cloneNode","showOriginalElementWhileDragging","setStyle","ghostElementAppendTo","insertBefore","nextSibling","ghostElement","setElementStyles","position","width","height","cursor","dragCursor","margin","ghostElementTemplate","viewRef_1","createEmbeddedView","innerHTML","rootNodes","node","Node","forEach","remove","indexOf","ghostElementCreated","emit","removeChild","currentDrag","dragEndData","dragEndData$","count","calledCount","dragCancelled","complete","dragEnd","removeClass","pairwise","previous","dragging","transform","-webkit-transform","-ms-transform","-moz-transform","-o-transform","dropData","ngOnChanges","changes","ngOnDestroy","unsubscribeEventListeners","hasEventListeners","keys","eventListenerSubscriptions","runOutsideAngular","mousedown","onMouseDown","mouseup","onMouseUp","touchstart","onTouchStart","touchend","onTouchEnd","touchcancel","mouseenter","onMouseEnter","mouseleave","onMouseLeave","mousemove","mouseMoveEvent","touchmove","touchMoveEvent","targetTouches","touches","changedTouches","setCursor","type","styles","key","window","pageYOffset","documentElement","pageXOffset","Renderer2","NgZone","ViewContainerRef","decorators","Optional","Inject","DOCUMENT","Input","Output","isCoordinateWithinRectangle","right","bottom","DroppableDirective","currentDragSubscription","drag$","currentDragDropData","dragOverActive","droppableElement","updateCache","deregisterScrollListener","overlaps$","scrollContainerRect","isWithinElement","overlapsChanged$","distinctUntilChanged","overlapsNow","dragOverClass","dragEnter","dragOver","didOverlap","dragLeave","drop","unsubscribe","DragAndDropModule","NgModule","declarations","exports"],"mappings":"6bA6BO,IAAIA,EAAW,WAQlB,OAPAA,EAAWC,OAAOC,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAII,KADTL,EAAIG,UAAUF,GACOJ,OAAOS,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,IAE9E,OAAON,IAEKU,MAAMC,KAAMP,YAGhC,SAAAQ,EA6EuBC,EAAGV,GACtB,IAAIW,EAAsB,mBAAXC,QAAyBF,EAAEE,OAAOC,UACjD,IAAKF,EAAG,OAAOD,EACf,IAAmBI,EAAYC,EAA3BhB,EAAIY,EAAEL,KAAKI,GAAOM,EAAK,GAC3B,IACI,WAAc,IAANhB,GAAsB,EAANA,QAAcc,EAAIf,EAAEkB,QAAQC,MAAMF,EAAGG,KAAKL,EAAEM,OAExE,MAAOC,GAASN,EAAI,CAAEM,MAAOA,WAEzB,IACQP,IAAMA,EAAEI,OAASP,EAAIZ,EAAU,YAAIY,EAAEL,KAAKP,WAExC,GAAIgB,EAAG,MAAMA,EAAEM,OAE7B,OAAOL,ECnIX,IAAAM,EAAA,yCAagB,IAAIC,EAAAA,mCAJnBC,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY,gHAVd,GCAAC,EAAA,WAME,SAAAA,EAAmBC,GAAApB,KAAAoB,WAAAA,6BAJpBC,EAAAA,UAASJ,KAAA,CAAC,CACTK,SAAU,6EAHQC,EAAAA,gBAApB,gBCuME,SAAAC,EACUC,EACAC,EACAC,EACAC,EACAC,EACYC,EACMC,GANlB/B,KAAAyB,QAAAA,EACAzB,KAAA0B,SAAAA,EACA1B,KAAA2B,gBAAAA,EACA3B,KAAA4B,KAAAA,EACA5B,KAAA6B,IAAAA,EACY7B,KAAA8B,gBAAAA,EACM9B,KAAA+B,SAAAA,gBA3HP,CAAEC,GAAG,EAAMC,GAAG,qBAMV,0BAMG,yCAMgB,kBAYvB,wBAwBH,IAAIC,EAAAA,4BAQV,IAAIA,EAAAA,sCAMM,IAAIA,EAAAA,2BAMf,IAAIA,EAAAA,0BAML,IAAIA,EAAAA,+BAKC,IAAInB,EAAAA,0BAKJ,IAAIA,EAAAA,wBAKN,IAAIA,EAAAA,wCAYb,iBAIe,IAAIA,EAAAA,eAevBS,EAAA5B,UAAAuC,SAAA,WAAA,IAAAC,EAAApC,KACEA,KAAKqC,sBAEL,IAAMC,EAAmCtC,KAAKuC,aAAaC,KACzDC,EAAAA,OAAO,WAAM,OAAAL,EAAKM,YAClBC,EAAAA,SAAS,SAACC,GAGJA,EAAiBC,MAAMC,iBACzBF,EAAiBC,MAAMC,kBAIzB,IAAMC,EAAoCX,EAAKV,SAASsB,cACtD,SAEFZ,EAAKV,SAASuB,aAAaF,EAAiB,OAAQ,YACpDX,EAAKV,SAASwB,YACZH,EACAX,EAAKV,SAASyB,WAAW,6LAS3Bf,EAAKL,SAASqB,KAAKF,YAAYH,GAE/B,IAAMM,EAAsBjB,EAAKkB,oBAE3BC,EAAyB,IAAIC,EAAAA,WAAW,SAAAC,GAC5C,IAAM3B,EAAkBM,EAAKN,gBACzBM,EAAKN,gBAAgBV,WAAWsC,cAChC,SACJ,OAAOtB,EAAKV,SAASiC,OAAO7B,EAAiB,SAAU,SAAAvB,GACrD,OAAAkD,EAAShD,KAAKF,OAEfiC,KACDoB,EAAAA,UAAUP,GACVQ,EAAAA,IAAI,WAAM,OAAAzB,EAAKkB,uBAGXQ,EAAe,IAAI/C,EAAAA,QACnBgD,EAAc,IAAIC,EAAAA,cAExB5B,EAAKR,KAAKqC,IAAI,WACZ7B,EAAK8B,gBAAgBzD,KAAK,CAAEuB,EAAG,EAAGC,EAAG,MAGvC,IAAMkC,EAAgBC,EAAAA,MACpBhC,EAAKiC,WACLjC,EAAKG,aACLwB,EACA3B,EAAKkC,UACL9B,KAAK+B,EAAAA,SAEDC,EAAcC,EAAAA,cAGlBrC,EAAKsC,aAAcnB,GAAwBf,KAC3CqB,EAAAA,IAAI,SAACc,OAAAC,EAAA3E,EAAA0E,EAAA,GAACE,EAAAD,EAAA,GAAkBE,EAAAF,EAAA,GACtB,MAAO,CACLd,aAAYA,EACZiB,WAAYF,EAAiBG,QAAUpC,EAAiBoC,QACxDC,WAAYJ,EAAiBK,QAAUtC,EAAiBsC,QACxDF,QAASH,EAAiBG,QAC1BE,QAASL,EAAiBK,QAC1BC,WAAYL,EAAOM,KACnBC,UAAWP,EAAOQ,OAGtBzB,EAAAA,IAAI,SAAA0B,GAaF,OAZInD,EAAKoD,aAAaxD,IACpBuD,EAASR,WACPU,KAAKC,MAAMH,EAASR,WAAa3C,EAAKoD,aAAaxD,GACnDI,EAAKoD,aAAaxD,GAGlBI,EAAKoD,aAAavD,IACpBsD,EAASN,WACPQ,KAAKC,MAAMH,EAASN,WAAa7C,EAAKoD,aAAavD,GACnDG,EAAKoD,aAAavD,GAGfsD,IAET1B,EAAAA,IAAI,SAAA0B,GASF,OARKnD,EAAKuD,SAAS3D,IACjBuD,EAASR,WAAa,GAGnB3C,EAAKuD,SAAS1D,IACjBsD,EAASN,WAAa,GAGjBM,IAET1B,EAAAA,IAAI,SAAA0B,GACF,IAAMK,EAAUL,EAASJ,WAAa9B,EAAoB+B,KACpDS,EAAUN,EAASF,UAAYhC,EAAoBiC,IACzD,OAAApG,EAAA,GACKqG,EAAQ,CACXvD,EAAGuD,EAASR,WAAaa,EACzB3D,EAAGsD,EAASN,WAAaY,MAG7BpD,EAAAA,OACE,SAACkC,OAAE3C,EAAA2C,EAAA3C,EAAGC,EAAA0C,EAAA1C,EAAQ,OAACG,EAAK0D,cAAgB1D,EAAK0D,aAAa,CAAE9D,EAACA,EAAEC,EAACA,MAE9D8D,EAAAA,UAAU5B,GACVI,EAAAA,SAGIyB,EAAexB,EAAYhC,KAC/ByD,EAAAA,KAAK,GACL1B,EAAAA,SAEI2B,EAAa1B,EAAYhC,KAC7B2D,EAAAA,SAAS,GACT5B,EAAAA,SAgHF,OA7GAyB,EAAaI,UAAU,WAUrB,GATAhE,EAAKR,KAAKqC,IAAI,WACZ7B,EAAKiE,UAAU5F,KAAK,CAAEsD,YAAWA,MAGnC3B,EAAKV,SAAS4E,SACZlE,EAAKX,QAAQiC,cACbtB,EAAKmE,iBAGHnE,EAAKoE,iBAAkB,CACzB,IAAMC,EAAOrE,EAAKX,QAAQiC,cAAcgD,wBAClCC,EAAQvE,EAAKX,QAAQiC,cAAckD,WACvC,GA+BF,GA7BKxE,EAAKyE,kCACRzE,EAAKV,SAASoF,SACZ1E,EAAKX,QAAQiC,cACb,aACA,UAIAtB,EAAK2E,qBACP3E,EAAK2E,qBAAqB7D,YAAYyD,GAEtCvE,EAAKX,QAAQiC,cAAwB,WAAEsD,aACrCL,EACAvE,EAAKX,QAAQiC,cAAcuD,aAI/B7E,EAAK8E,aAAeP,EAEpBvE,EAAK+E,iBAAiBR,EAAO,CAC3BS,SAAU,QACV9B,IAAQmB,EAAKnB,IAAG,KAChBF,KAASqB,EAAKrB,KAAI,KAClBiC,MAAUZ,EAAKY,MAAK,KACpBC,OAAWb,EAAKa,OAAM,KACtBC,OAAQnF,EAAKoF,WACbC,OAAQ,MAGNrF,EAAKsF,qBAAsB,CAC7B,IAAMC,EAAUvF,EAAKP,IAAI+F,mBACvBxF,EAAKsF,sBAEPf,EAAMkB,UAAY,GAClBF,EAAQG,UACLrF,OAAO,SAAAsF,GAAQ,OAAAA,aAAgBC,OAC/BC,QAAQ,SAAAF,GACPpB,EAAMzD,YAAY6E,KAEtB7B,EAAWE,UAAU,WACnBhE,EAAKP,IAAIqG,OAAO9F,EAAKP,IAAIsG,QAAQR,MAIrCvF,EAAKR,KAAKqC,IAAI,WACZ7B,EAAKgG,oBAAoBC,SAG3BnC,EAAWE,UAAU,WACnBO,EAAmB,cAAE2B,YAAY3B,GACjCvE,EAAK8E,aAAe,KACpB9E,EAAKV,SAASoF,SACZ1E,EAAKX,QAAQiC,cACb,aACA,MAKNtB,EAAKT,gBAAgB4G,YAAY9H,KAAKqD,KAGxCoC,EACG1D,KACCG,EAAAA,SAAS,SAAA6F,GACP,IAAMC,EAAe1E,EAAYvB,KAC/BkG,EAAAA,QACAzC,EAAAA,KAAK,GACLpC,EAAAA,IAAI,SAAA8E,GAAe,OAAAzJ,EAAA,GACdsJ,EAAW,CACdI,cAA6B,EAAdD,OAInB,OADA5E,EAAY8E,WACLJ,KAGVrC,UAAU,SAACzB,OAAE3C,EAAA2C,EAAA3C,EAAGC,EAAA0C,EAAA1C,EAAG2G,EAAAjE,EAAAiE,cAClBxG,EAAKR,KAAKqC,IAAI,WACZ7B,EAAK0G,QAAQrI,KAAK,CAAEuB,EAACA,EAAEC,EAACA,EAAE2G,cAAaA,MAEzCxG,EAAKV,SAASqH,YACZ3G,EAAKX,QAAQiC,cACbtB,EAAKmE,iBAEPzC,EAAa+E,aAGjBzE,EAAAA,MAAMD,EAAe+B,GAClB1D,KAAKyD,EAAAA,KAAK,IACVG,UAAU,WACThE,EAAKL,SAASqB,KAAKkF,YAAYvF,KAG5ByB,IAETD,EAAAA,SAGFH,EAAAA,MACE9B,EAAgBE,KACdyD,EAAAA,KAAK,GACLpC,EAAAA,IAAI,SAAAjD,GAAS,MAAA,CAAA,CAAGA,MAElB0B,EAAgBE,KAAKwG,EAAAA,aAEpBxG,KACCC,EAAAA,OAAO,SAACkC,OAAAC,EAAA3E,EAAA0E,EAAA,GAACsE,EAAArE,EAAA,GAAUnE,EAAAmE,EAAA,GACjB,OAAKqE,IAGEA,EAASjH,IAAMvB,EAAKuB,GAAKiH,EAAShH,IAAMxB,EAAKwB,KAEtD4B,EAAAA,IAAI,SAACc,OAAAC,EAAA3E,EAAA0E,EAAA,GAACC,EAAA,GAAoB,OAAVA,EAAA,MAEjBwB,UACC,SAACzB,OAAE3C,EAAA2C,EAAA3C,EAAGC,EAAA0C,EAAA1C,EAAG6B,EAAAa,EAAAb,aAAckB,EAAAL,EAAAK,QAASE,EAAAP,EAAAO,QAASH,EAAAJ,EAAAI,WAAYE,EAAAN,EAAAM,WAInD,GAHA7C,EAAKR,KAAKqC,IAAI,WACZ7B,EAAK8G,SAASzI,KAAK,CAAEuB,EAACA,EAAEC,EAACA,MAEvBG,EAAK8E,aAAc,CACrB,IAAMiC,EAAY,aAAapE,EAAU,OAAOE,EAAU,MAC1D7C,EAAK+E,iBAAiB/E,EAAK8E,aAAc,CACvCiC,UAASA,EACTC,oBAAqBD,EACrBE,gBAAiBF,EACjBG,iBAAkBH,EAClBI,eAAgBJ,IAGpBrF,EAAarD,KAAK,CAChBuE,QAAOA,EACPE,QAAOA,EACPsE,SAAUpH,EAAKoH,cAMzBhI,EAAA5B,UAAA6J,YAAA,SAAYC,GACNA,EAAO,UACT1J,KAAKqC,uBAITb,EAAA5B,UAAA+J,YAAA,WACE3J,KAAK4J,4BACL5J,KAAKuC,aAAasG,WAClB7I,KAAK0E,aAAamE,WAClB7I,KAAKqE,WAAWwE,WAChB7I,KAAKsE,SAAS7D,QAGRe,EAAA5B,UAAAyC,0CACAK,EAAmB1C,KAAK0C,UACxBmH,EACkD,EAAtD1K,OAAO2K,KAAK9J,KAAK+J,4BAA4BrK,OAE3CgD,IAAYmH,EACd7J,KAAK4B,KAAKoI,kBAAkB,WAC1B5H,EAAK2H,2BAA2BE,UAAY7H,EAAKV,SAASiC,OACxDvB,EAAKX,QAAQiC,cACb,YACA,SAACb,GACCT,EAAK8H,YAAYrH,KAIrBT,EAAK2H,2BAA2BI,QAAU/H,EAAKV,SAASiC,OACtD,WACA,UACA,SAACd,GACCT,EAAKgI,UAAUvH,KAInBT,EAAK2H,2BAA2BM,WAAajI,EAAKV,SAASiC,OACzDvB,EAAKX,QAAQiC,cACb,aACA,SAACb,GACCT,EAAKkI,aAAazH,KAItBT,EAAK2H,2BAA2BQ,SAAWnI,EAAKV,SAASiC,OACvD,WACA,WACA,SAACd,GACCT,EAAKoI,WAAW3H,KAIpBT,EAAK2H,2BAA2BU,YAAcrI,EAAKV,SAASiC,OAC1D,WACA,cACA,SAACd,GACCT,EAAKoI,WAAW3H,KAIpBT,EAAK2H,2BAA2BW,WAAatI,EAAKV,SAASiC,OACzDvB,EAAKX,QAAQiC,cACb,aACA,WACEtB,EAAKuI,iBAITvI,EAAK2H,2BAA2Ba,WAAaxI,EAAKV,SAASiC,OACzDvB,EAAKX,QAAQiC,cACb,aACA,WACEtB,EAAKyI,oBAIDnI,GAAWmH,GACrB7J,KAAK4J,6BAIDpI,EAAA5B,UAAAsK,qBAAYrH,cACb7C,KAAK+J,2BAA2Be,YACnC9K,KAAK+J,2BAA2Be,UAAY9K,KAAK0B,SAASiC,OACxD,WACA,YACA,SAACoH,GACC3I,EAAKsC,aAAajE,KAAK,CACrBoC,MAAOkI,EACP/F,QAAS+F,EAAe/F,QACxBE,QAAS6F,EAAe7F,aAKhClF,KAAKuC,aAAa9B,KAAK,CACrBoC,MAAKA,EACLmC,QAASnC,EAAMmC,QACfE,QAASrC,EAAMqC,WAIX1D,EAAA5B,UAAAwK,mBAAUvH,GACZ7C,KAAK+J,2BAA2Be,YAClC9K,KAAK+J,2BAA2Be,mBACzB9K,KAAK+J,2BAA2Be,WAEzC9K,KAAKqE,WAAW5D,KAAK,CACnBoC,MAAKA,EACLmC,QAASnC,EAAMmC,QACfE,QAASrC,EAAMqC,WAIX1D,EAAA5B,UAAA0K,sBAAazH,cACd7C,KAAK+J,2BAA2BiB,YACnChL,KAAK+J,2BAA2BiB,UAAYhL,KAAK0B,SAASiC,OACxD,WACA,YACA,SAACsH,GACC7I,EAAKsC,aAAajE,KAAK,CACrBoC,MAAOoI,EACPjG,QAASiG,EAAeC,cAAc,GAAGlG,QACzCE,QAAS+F,EAAeC,cAAc,GAAGhG,aAKjDlF,KAAKuC,aAAa9B,KAAK,CACrBoC,MAAKA,EACLmC,QAASnC,EAAMsI,QAAQ,GAAGnG,QAC1BE,QAASrC,EAAMsI,QAAQ,GAAGjG,WAItB1D,EAAA5B,UAAA4K,oBAAW3H,GACb7C,KAAK+J,2BAA2BiB,YAClChL,KAAK+J,2BAA2BiB,mBACzBhL,KAAK+J,2BAA2BiB,WAEzChL,KAAKqE,WAAW5D,KAAK,CACnBoC,MAAKA,EACLmC,QAASnC,EAAMuI,eAAe,GAAGpG,QACjCE,QAASrC,EAAMuI,eAAe,GAAGlG,WAI7B1D,EAAA5B,UAAA+K,wBACN3K,KAAKqL,UAAUrL,KAAKwH,aAGdhG,EAAA5B,UAAAiL,wBACN7K,KAAKqL,UAAU,KAGT7J,EAAA5B,UAAA8C,mBACN,OAAO1C,KAAK2F,SAAS3D,GAAKhC,KAAK2F,SAAS1D,GAGlCT,EAAA5B,UAAAyL,mBAAUzK,GAChBZ,KAAK0B,SAASoF,SAAS9G,KAAKyB,QAAQiC,cAAe,SAAU9C,IAGvDY,EAAA5B,UAAAgK,gDACNzK,OAAO2K,KAAK9J,KAAK+J,4BAA4B9B,QAAQ,SAAAqD,GACnD,EAAcvB,2BAA2BuB,YAClC,EAAcvB,2BAA2BuB,MAI5C9J,EAAA5B,UAAAuH,0BACN1F,EACA8J,cAEApM,OAAO2K,KAAKyB,GAAQtD,QAAQ,SAAAuD,GAC1BpJ,EAAKV,SAASoF,SAASrF,EAAS+J,EAAKD,EAAOC,OAIxChK,EAAA5B,UAAA0D,6BACN,OAAItD,KAAK8B,gBACA,CACLwD,IAAKtF,KAAK8B,gBAAgBV,WAAWsC,cAAc2B,UACnDD,KAAMpF,KAAK8B,gBAAgBV,WAAWsC,cAAcyB,YAG/C,CACLG,IAAKmG,OAAOC,aAAe3J,SAAS4J,gBAAgBtG,UACpDD,KAAMqG,OAAOG,aAAe7J,SAAS4J,gBAAgBxG,iCA/lB5D9D,EAAAA,UAASJ,KAAA,CAAC,CACTK,SAAU,8DAnEVC,EAAAA,kBACAsK,EAAAA,iBA0BwB/K,SApBxBgL,EAAAA,cAIAC,EAAAA,wBAkBO5K,EAAiC6K,WAAA,CAAA,CAAAV,KA6KrCW,EAAAA,8CACAC,EAAAA,OAAMjL,KAAA,CAACkL,EAAAA,iDAlITC,EAAAA,wBAMAA,EAAAA,4BAMAA,EAAAA,gCAMAA,EAAAA,gDAMAA,EAAAA,4BAMAA,EAAAA,0BAMAA,EAAAA,+BAMAA,EAAAA,oCAMAA,EAAAA,oCAMAA,EAAAA,+BAMAC,EAAAA,0BAQAA,EAAAA,oCAMAA,EAAAA,yBAMAA,EAAAA,wBAMAA,EAAAA,eCjJH,SAAAC,EACEtH,EACAE,EACAuB,GAEA,OACEzB,GAAWyB,EAAKrB,MAChBJ,GAAWyB,EAAK8F,OAChBrH,GAAWuB,EAAKnB,KAChBJ,GAAWuB,EAAK+F,wBAkDlB,SAAAC,EACUhL,EACAE,EACAC,EACAF,EACYI,GAJZ9B,KAAAyB,QAAAA,EACAzB,KAAA2B,gBAAAA,EACA3B,KAAA4B,KAAAA,EACA5B,KAAA0B,SAAAA,EACY1B,KAAA8B,gBAAAA,iBA3BV,IAAII,EAAAA,4BAMJ,IAAIA,EAAAA,2BAML,IAAIA,EAAAA,uBAMR,IAAIA,EAAAA,oBAYXuK,EAAA7M,UAAAuC,SAAA,WAAA,IAAAC,EAAApC,KACEA,KAAK0M,wBAA0B1M,KAAK2B,gBAAgB4G,YAAYnC,UAC9D,SAAAuG,GACEvK,EAAKV,SAAS4E,SACZlE,EAAKX,QAAQiC,cACbtB,EAAKmE,iBAEP,IAkBIqG,EAiCAC,EAnDEC,EAIF,CACFC,aAAa,GAGTC,EAA2B5K,EAAKV,SAASiC,OAC7CvB,EAAKN,gBACDM,EAAKN,gBAAgBV,WAAWsC,cAChC,SACJ,SACA,WACEoJ,EAAiBC,aAAc,IAK7BE,EAAYN,EAAMnK,KACtBqB,EAAAA,IAAI,SAACc,OAAEK,EAAAL,EAAAK,QAASE,EAAAP,EAAAO,QAASsE,EAAA7E,EAAA6E,SACvBoD,EAAsBpD,EAClBsD,EAAiBC,cACnBD,EAAiBrG,KAAOrE,EAAKX,QAAQiC,cAAcgD,wBAC/CtE,EAAKN,kBACPgL,EAAiBI,oBAAsB9K,EAAKN,gBAAgBV,WAAWsC,cAAcgD,yBAEvFoG,EAAiBC,aAAc,GAEjC,IAAMI,EAAkBb,EACtBtH,EACAE,EACA4H,EAAmC,MAErC,OAAIA,EAAiBI,oBAEjBC,GACAb,EACEtH,EACAE,EACA4H,EAAkD,qBAI/CK,KAKPC,EAAmBH,EAAUzK,KAAK6K,EAAAA,wBAIxCD,EACG5K,KAAKC,EAAAA,OAAO,SAAA6K,GAAe,OAAAA,KAC3BlH,UAAU,WACTyG,GAAiB,EACjBzK,EAAKV,SAAS4E,SACZlE,EAAKX,QAAQiC,cACbtB,EAAKmL,eAEPnL,EAAKR,KAAKqC,IAAI,WACZ7B,EAAKoL,UAAU/M,KAAK,CAClB+I,SAAUoD,QAKlBK,EAAUzK,KAAKC,EAAAA,OAAO,SAAA6K,GAAe,OAAAA,KAAclH,UAAU,WAC3DhE,EAAKR,KAAKqC,IAAI,WACZ7B,EAAKqL,SAAShN,KAAK,CACjB+I,SAAUoD,QAKhBQ,EACG5K,KACCwG,EAAAA,WACAvG,EAAAA,OAAO,SAACkC,OAAAC,EAAA3E,EAAA0E,EAAA,GAAC+I,EAAA9I,EAAA,GAAY0I,EAAA1I,EAAA,GAAiB,OAAA8I,IAAeJ,KAEtDlH,UAAU,WACTyG,GAAiB,EACjBzK,EAAKV,SAASqH,YACZ3G,EAAKX,QAAQiC,cACbtB,EAAKmL,eAEPnL,EAAKR,KAAKqC,IAAI,WACZ7B,EAAKuL,UAAUlN,KAAK,CAClB+I,SAAUoD,QAKlBD,EAAMvG,UAAU,CACdyC,SAAU,WACRmE,IACA5K,EAAKV,SAASqH,YACZ3G,EAAKX,QAAQiC,cACbtB,EAAKmE,iBAEHsG,IACFzK,EAAKV,SAASqH,YACZ3G,EAAKX,QAAQiC,cACbtB,EAAKmL,eAEPnL,EAAKR,KAAKqC,IAAI,WACZ7B,EAAKwL,KAAKnN,KAAK,CACb+I,SAAUoD,aAU1BH,EAAA7M,UAAA+J,YAAA,WACM3J,KAAK0M,yBACP1M,KAAK0M,wBAAwBmB,mCAjLlCxM,EAAAA,UAASJ,KAAA,CAAC,CACTK,SAAU,8DAhCVC,EAAAA,kBAWOT,SAPPgL,EAAAA,cAEAD,EAAAA,iBAMO1K,EAAiC6K,WAAA,CAAA,CAAAV,KAkErCW,EAAAA,qDAxCFG,EAAAA,+BAMAA,EAAAA,yBAMAC,EAAAA,0BAMAA,EAAAA,yBAMAA,EAAAA,qBAMAA,EAAAA,eCvEHyB,EAAA,oDAKCC,EAAAA,SAAQ9M,KAAA,CAAC,CACR+M,aAAc,CACZxM,EACAiL,EACAtL,GAEF8M,QAAS,CACPzM,EACAiL,EACAtL,SAdJ","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\n\nexport interface CurrentDragData {\n  clientX: number;\n  clientY: number;\n  dropData: any;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DraggableHelper {\n  currentDrag = new Subject<Subject<CurrentDragData>>();\n}\n","import { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  selector: '[mwlDraggableScrollContainer]'\n})\nexport class DraggableScrollContainerDirective {\n  constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  Renderer2,\n  Output,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnChanges,\n  NgZone,\n  SimpleChanges,\n  Inject,\n  TemplateRef,\n  ViewContainerRef,\n  Optional\n} from '@angular/core';\nimport { Subject, Observable, merge, ReplaySubject, combineLatest } from 'rxjs';\nimport {\n  map,\n  mergeMap,\n  takeUntil,\n  take,\n  takeLast,\n  pairwise,\n  share,\n  filter,\n  count,\n  startWith\n} from 'rxjs/operators';\nimport { CurrentDragData, DraggableHelper } from './draggable-helper.provider';\nimport { DOCUMENT } from '@angular/common';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface DragAxis {\n  x: boolean;\n  y: boolean;\n}\n\nexport interface SnapGrid {\n  x?: number;\n  y?: number;\n}\n\nexport interface DragPointerDownEvent extends Coordinates {}\n\nexport interface DragStartEvent {\n  cancelDrag$: ReplaySubject<void>;\n}\n\nexport interface DragMoveEvent extends Coordinates {}\n\nexport interface DragEndEvent extends Coordinates {\n  dragCancelled: boolean;\n}\n\nexport type ValidateDrag = (coordinates: Coordinates) => boolean;\n\nexport interface PointerEvent {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\n@Directive({\n  selector: '[mwlDraggable]'\n})\nexport class DraggableDirective implements OnInit, OnChanges, OnDestroy {\n  /**\n   * an object of data you can pass to the drop event\n   */\n  @Input()\n  dropData: any;\n\n  /**\n   * The axis along which the element is draggable\n   */\n  @Input()\n  dragAxis: DragAxis = { x: true, y: true };\n\n  /**\n   * Snap all drags to an x / y grid\n   */\n  @Input()\n  dragSnapGrid: SnapGrid = {};\n\n  /**\n   * Show a ghost element that shows the drag when dragging\n   */\n  @Input()\n  ghostDragEnabled: boolean = true;\n\n  /**\n   * Show the original element when ghostDragEnabled is true\n   */\n  @Input()\n  showOriginalElementWhileDragging: boolean = false;\n\n  /**\n   * Allow custom behaviour to control when the element is dragged\n   */\n  @Input()\n  validateDrag: ValidateDrag;\n\n  /**\n   * The cursor to use when dragging the element\n   */\n  @Input()\n  dragCursor: string = '';\n\n  /**\n   * The css class to apply when the element is being dragged\n   */\n  @Input()\n  dragActiveClass: string;\n\n  /**\n   * The element the ghost element will be appended to. Default is next to the dragged element\n   */\n  @Input()\n  ghostElementAppendTo: HTMLElement;\n\n  /**\n   * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.\n   */\n  @Input()\n  ghostElementTemplate: TemplateRef<any>;\n\n  /**\n   * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n   */\n  @Output()\n  dragPointerDown = new EventEmitter<DragPointerDownEvent>();\n\n  /**\n   * Called when the element has started to be dragged.\n   * Only called after at least one mouse or touch move event.\n   * If you call $event.cancelDrag$.emit() it will cancel the current drag\n   */\n  @Output()\n  dragStart = new EventEmitter<DragStartEvent>();\n\n  /**\n   * Called after the ghost element has been created\n   */\n  @Output()\n  ghostElementCreated = new EventEmitter();\n\n  /**\n   * Called when the element is being dragged\n   */\n  @Output()\n  dragging = new EventEmitter<DragMoveEvent>();\n\n  /**\n   * Called after the element is dragged\n   */\n  @Output()\n  dragEnd = new EventEmitter<DragEndEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerDown$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerMove$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerUp$ = new Subject<PointerEvent>();\n\n  private eventListenerSubscriptions: {\n    mousemove?: () => void;\n    mousedown?: () => void;\n    mouseup?: () => void;\n    mouseenter?: () => void;\n    mouseleave?: () => void;\n    touchstart?: () => void;\n    touchmove?: () => void;\n    touchend?: () => void;\n    touchcancel?: () => void;\n  } = {};\n\n  private ghostElement: HTMLElement | null;\n\n  private destroy$ = new Subject();\n\n  /**\n   * @hidden\n   */\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private vcr: ViewContainerRef,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective,\n    @Inject(DOCUMENT) private document: any\n  ) {}\n\n  ngOnInit(): void {\n    this.checkEventListeners();\n\n    const pointerDragged$: Observable<any> = this.pointerDown$.pipe(\n      filter(() => this.canDrag()),\n      mergeMap((pointerDownEvent: PointerEvent) => {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation) {\n          pointerDownEvent.event.stopPropagation();\n        }\n\n        // hack to prevent text getting selected in safari while dragging\n        const globalDragStyle: HTMLStyleElement = this.renderer.createElement(\n          'style'\n        );\n        this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');\n        this.renderer.appendChild(\n          globalDragStyle,\n          this.renderer.createText(`\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        `)\n        );\n        this.document.head.appendChild(globalDragStyle);\n\n        const startScrollPosition = this.getScrollPosition();\n\n        const scrollContainerScroll$ = new Observable(observer => {\n          const scrollContainer = this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window';\n          return this.renderer.listen(scrollContainer, 'scroll', e =>\n            observer.next(e)\n          );\n        }).pipe(\n          startWith(startScrollPosition),\n          map(() => this.getScrollPosition())\n        );\n\n        const currentDrag$ = new Subject<CurrentDragData>();\n        const cancelDrag$ = new ReplaySubject<void>();\n\n        this.zone.run(() => {\n          this.dragPointerDown.next({ x: 0, y: 0 });\n        });\n\n        const dragComplete$ = merge(\n          this.pointerUp$,\n          this.pointerDown$,\n          cancelDrag$,\n          this.destroy$\n        ).pipe(share());\n\n        const pointerMove = combineLatest<\n          PointerEvent,\n          { top: number; left: number }\n        >(this.pointerMove$, scrollContainerScroll$).pipe(\n          map(([pointerMoveEvent, scroll]) => {\n            return {\n              currentDrag$,\n              transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n              transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n              clientX: pointerMoveEvent.clientX,\n              clientY: pointerMoveEvent.clientY,\n              scrollLeft: scroll.left,\n              scrollTop: scroll.top\n            };\n          }),\n          map(moveData => {\n            if (this.dragSnapGrid.x) {\n              moveData.transformX =\n                Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                this.dragSnapGrid.x;\n            }\n\n            if (this.dragSnapGrid.y) {\n              moveData.transformY =\n                Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                this.dragSnapGrid.y;\n            }\n\n            return moveData;\n          }),\n          map(moveData => {\n            if (!this.dragAxis.x) {\n              moveData.transformX = 0;\n            }\n\n            if (!this.dragAxis.y) {\n              moveData.transformY = 0;\n            }\n\n            return moveData;\n          }),\n          map(moveData => {\n            const scrollX = moveData.scrollLeft - startScrollPosition.left;\n            const scrollY = moveData.scrollTop - startScrollPosition.top;\n            return {\n              ...moveData,\n              x: moveData.transformX + scrollX,\n              y: moveData.transformY + scrollY\n            };\n          }),\n          filter(\n            ({ x, y }) => !this.validateDrag || this.validateDrag({ x, y })\n          ),\n          takeUntil(dragComplete$),\n          share()\n        );\n\n        const dragStarted$ = pointerMove.pipe(\n          take(1),\n          share()\n        );\n        const dragEnded$ = pointerMove.pipe(\n          takeLast(1),\n          share()\n        );\n\n        dragStarted$.subscribe(() => {\n          this.zone.run(() => {\n            this.dragStart.next({ cancelDrag$ });\n          });\n\n          this.renderer.addClass(\n            this.element.nativeElement,\n            this.dragActiveClass\n          );\n\n          if (this.ghostDragEnabled) {\n            const rect = this.element.nativeElement.getBoundingClientRect();\n            const clone = this.element.nativeElement.cloneNode(\n              true\n            ) as HTMLElement;\n            if (!this.showOriginalElementWhileDragging) {\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                'hidden'\n              );\n            }\n\n            if (this.ghostElementAppendTo) {\n              this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              this.element.nativeElement.parentNode!.insertBefore(\n                clone,\n                this.element.nativeElement.nextSibling\n              );\n            }\n\n            this.ghostElement = clone;\n\n            this.setElementStyles(clone, {\n              position: 'fixed',\n              top: `${rect.top}px`,\n              left: `${rect.left}px`,\n              width: `${rect.width}px`,\n              height: `${rect.height}px`,\n              cursor: this.dragCursor,\n              margin: '0'\n            });\n\n            if (this.ghostElementTemplate) {\n              const viewRef = this.vcr.createEmbeddedView(\n                this.ghostElementTemplate\n              );\n              clone.innerHTML = '';\n              viewRef.rootNodes\n                .filter(node => node instanceof Node)\n                .forEach(node => {\n                  clone.appendChild(node);\n                });\n              dragEnded$.subscribe(() => {\n                this.vcr.remove(this.vcr.indexOf(viewRef));\n              });\n            }\n\n            this.zone.run(() => {\n              this.ghostElementCreated.emit();\n            });\n\n            dragEnded$.subscribe(() => {\n              clone.parentElement!.removeChild(clone);\n              this.ghostElement = null;\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                ''\n              );\n            });\n          }\n\n          this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n\n        dragEnded$\n          .pipe(\n            mergeMap(dragEndData => {\n              const dragEndData$ = cancelDrag$.pipe(\n                count(),\n                take(1),\n                map(calledCount => ({\n                  ...dragEndData,\n                  dragCancelled: calledCount > 0\n                }))\n              );\n              cancelDrag$.complete();\n              return dragEndData$;\n            })\n          )\n          .subscribe(({ x, y, dragCancelled }) => {\n            this.zone.run(() => {\n              this.dragEnd.next({ x, y, dragCancelled });\n            });\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragActiveClass\n            );\n            currentDrag$.complete();\n          });\n\n        merge(dragComplete$, dragEnded$)\n          .pipe(take(1))\n          .subscribe(() => {\n            this.document.head.removeChild(globalDragStyle);\n          });\n\n        return pointerMove;\n      }),\n      share()\n    );\n\n    merge(\n      pointerDragged$.pipe(\n        take(1),\n        map(value => [, value])\n      ),\n      pointerDragged$.pipe(pairwise())\n    )\n      .pipe(\n        filter(([previous, next]) => {\n          if (!previous) {\n            return true;\n          }\n          return previous.x !== next.x || previous.y !== next.y;\n        }),\n        map(([previous, next]) => next)\n      )\n      .subscribe(\n        ({ x, y, currentDrag$, clientX, clientY, transformX, transformY }) => {\n          this.zone.run(() => {\n            this.dragging.next({ x, y });\n          });\n          if (this.ghostElement) {\n            const transform = `translate(${transformX}px, ${transformY}px)`;\n            this.setElementStyles(this.ghostElement, {\n              transform,\n              '-webkit-transform': transform,\n              '-ms-transform': transform,\n              '-moz-transform': transform,\n              '-o-transform': transform\n            });\n          }\n          currentDrag$.next({\n            clientX,\n            clientY,\n            dropData: this.dropData\n          });\n        }\n      );\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  private checkEventListeners(): void {\n    const canDrag: boolean = this.canDrag();\n    const hasEventListeners: boolean =\n      Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(\n          this.element.nativeElement,\n          'mousedown',\n          (event: MouseEvent) => {\n            this.onMouseDown(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen(\n          'document',\n          'mouseup',\n          (event: MouseEvent) => {\n            this.onMouseUp(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(\n          this.element.nativeElement,\n          'touchstart',\n          (event: TouchEvent) => {\n            this.onTouchStart(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchend = this.renderer.listen(\n          'document',\n          'touchend',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen(\n          'document',\n          'touchcancel',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseenter',\n          () => {\n            this.onMouseEnter();\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseleave',\n          () => {\n            this.onMouseLeave();\n          }\n        );\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove = this.renderer.listen(\n        'document',\n        'mousemove',\n        (mouseMoveEvent: MouseEvent) => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        }\n      );\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove();\n      delete this.eventListenerSubscriptions.mousemove;\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onTouchStart(event: TouchEvent): void {\n    if (!this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove = this.renderer.listen(\n        'document',\n        'touchmove',\n        (touchMoveEvent: TouchEvent) => {\n          this.pointerMove$.next({\n            event: touchMoveEvent,\n            clientX: touchMoveEvent.targetTouches[0].clientX,\n            clientY: touchMoveEvent.targetTouches[0].clientY\n          });\n        }\n      );\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  private onTouchEnd(event: TouchEvent): void {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  private onMouseEnter(): void {\n    this.setCursor(this.dragCursor);\n  }\n\n  private onMouseLeave(): void {\n    this.setCursor('');\n  }\n\n  private canDrag(): boolean {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  private setCursor(value: string): void {\n    this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      (this as any).eventListenerSubscriptions[type]();\n      delete (this as any).eventListenerSubscriptions[type];\n    });\n  }\n\n  private setElementStyles(\n    element: HTMLElement,\n    styles: { [key: string]: string }\n  ) {\n    Object.keys(styles).forEach(key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  private getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || document.documentElement.scrollTop,\n        left: window.pageXOffset || document.documentElement.scrollLeft\n      };\n    }\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  OnDestroy,\n  Output,\n  EventEmitter,\n  NgZone,\n  Input,\n  Renderer2,\n  Optional\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { distinctUntilChanged, pairwise, filter, map } from 'rxjs/operators';\nimport { DraggableHelper } from './draggable-helper.provider';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\nfunction isCoordinateWithinRectangle(\n  clientX: number,\n  clientY: number,\n  rect: ClientRect\n): boolean {\n  return (\n    clientX >= rect.left &&\n    clientX <= rect.right &&\n    clientY >= rect.top &&\n    clientY <= rect.bottom\n  );\n}\n\nexport interface DropEvent<T = any> {\n  dropData: T;\n}\n\n@Directive({\n  selector: '[mwlDroppable]'\n})\nexport class DroppableDirective implements OnInit, OnDestroy {\n  /**\n   * Added to the element when an element is dragged over it\n   */\n  @Input()\n  dragOverClass: string;\n\n  /**\n   * Added to the element any time a draggable element is being dragged\n   */\n  @Input()\n  dragActiveClass: string;\n\n  /**\n   * Called when a draggable element starts overlapping the element\n   */\n  @Output()\n  dragEnter = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element stops overlapping the element\n   */\n  @Output()\n  dragLeave = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is moved over the element\n   */\n  @Output()\n  dragOver = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is dropped on this element\n   */\n  @Output()\n  drop = new EventEmitter<DropEvent>(); // tslint:disable-line no-output-named-after-standard-event\n\n  currentDragSubscription: Subscription;\n\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private renderer: Renderer2,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective\n  ) {}\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      drag$ => {\n        this.renderer.addClass(\n          this.element.nativeElement,\n          this.dragActiveClass\n        );\n        const droppableElement: {\n          rect?: ClientRect;\n          updateCache: boolean;\n          scrollContainerRect?: ClientRect;\n        } = {\n          updateCache: true\n        };\n\n        const deregisterScrollListener = this.renderer.listen(\n          this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window',\n          'scroll',\n          () => {\n            droppableElement.updateCache = true;\n          }\n        );\n\n        let currentDragDropData: any;\n        const overlaps$ = drag$.pipe(\n          map(({ clientX, clientY, dropData }) => {\n            currentDragDropData = dropData;\n            if (droppableElement.updateCache) {\n              droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n              if (this.scrollContainer) {\n                droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n              }\n              droppableElement.updateCache = false;\n            }\n            const isWithinElement = isCoordinateWithinRectangle(\n              clientX,\n              clientY,\n              droppableElement.rect as ClientRect\n            );\n            if (droppableElement.scrollContainerRect) {\n              return (\n                isWithinElement &&\n                isCoordinateWithinRectangle(\n                  clientX,\n                  clientY,\n                  droppableElement.scrollContainerRect as ClientRect\n                )\n              );\n            } else {\n              return isWithinElement;\n            }\n          })\n        );\n\n        const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n\n        let dragOverActive: boolean; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged$\n          .pipe(filter(overlapsNow => overlapsNow))\n          .subscribe(() => {\n            dragOverActive = true;\n            this.renderer.addClass(\n              this.element.nativeElement,\n              this.dragOverClass\n            );\n            this.zone.run(() => {\n              this.dragEnter.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        overlaps$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n          this.zone.run(() => {\n            this.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n\n        overlapsChanged$\n          .pipe(\n            pairwise(),\n            filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)\n          )\n          .subscribe(() => {\n            dragOverActive = false;\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragOverClass\n            );\n            this.zone.run(() => {\n              this.dragLeave.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        drag$.subscribe({\n          complete: () => {\n            deregisterScrollListener();\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragActiveClass\n            );\n            if (dragOverActive) {\n              this.renderer.removeClass(\n                this.element.nativeElement,\n                this.dragOverClass\n              );\n              this.zone.run(() => {\n                this.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      }\n    );\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { DraggableDirective } from './draggable.directive';\nimport { DroppableDirective } from './droppable.directive';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\n@NgModule({\n  declarations: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective\n  ],\n  exports: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective\n  ]\n})\nexport class DragAndDropModule {}\n"]}